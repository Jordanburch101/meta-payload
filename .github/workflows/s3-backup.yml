name: Supabase S3 to Dropbox Incremental Backup

on:
  schedule:
    - cron: '0 0 * * *'  # Runs at 00:00 UTC daily
  workflow_dispatch:      # Allows manual trigger

env:
  S3_ENDPOINT: 'https://vfmxvvugriytncpzypvm.supabase.co/storage/v1/s3'
  S3_REGION: 'ap-southeast-2'
  BACKUP_RETENTION_DAYS: 30
  BETTER_STACK_HEARTBEAT: 'https://uptime.betterstack.com/api/v1/heartbeat/PgcWvW8C3Navz8Eo3aYC1WF4'

jobs:
  backup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 dropbox requests

      - name: Start Heartbeat
        run: |
          curl -X GET ${{ env.BETTER_STACK_HEARTBEAT }}/start

      - name: Perform incremental backup and cleanup
        env:
          DROPBOX_APP_KEY: ${{ secrets.DROPBOX_APP_KEY }}
          DROPBOX_APP_SECRET: ${{ secrets.DROPBOX_APP_SECRET }}
          DROPBOX_REFRESH_TOKEN: ${{ secrets.DROPBOX_REFRESH_TOKEN }}
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          S3_ACCESS_KEY_ID: ${{ secrets.S3_ACCESS_KEY_ID }}
          S3_SECRET_ACCESS_KEY: ${{ secrets.S3_SECRET_ACCESS_KEY }}
        run: |
          python -c '
          import boto3
          import dropbox
          from dropbox import DropboxOAuth2FlowNoRedirect
          import datetime
          import os
          import json
          import shutil
          import requests
          import time
          from pathlib import Path
          from datetime import datetime, timedelta
          
          def send_heartbeat(status, msg=""):
              """Send heartbeat to Better Stack"""
              heartbeat_url = os.environ["BETTER_STACK_HEARTBEAT"]
              if status == "fail":
                  heartbeat_url += "/fail"
              try:
                  response = requests.get(f"{heartbeat_url}?msg={msg}")
                  print(f"Heartbeat sent: {status} - {msg}")
              except Exception as e:
                  print(f"Failed to send heartbeat: {str(e)}")

          def refresh_access_token():
              """Manually refresh the access token using refresh token"""
              try:
                  app_key = os.environ["DROPBOX_APP_KEY"]
                  app_secret = os.environ["DROPBOX_APP_SECRET"]
                  refresh_token = os.environ["DROPBOX_REFRESH_TOKEN"]

                  print("Attempting to refresh access token...")
                  print(f"Using app key: {app_key[:4]}...{app_key[-4:]}")  # Only show first/last 4 chars
                  print(f"Refresh token length: {len(refresh_token)}")

                  # Manually construct the token refresh request
                  token_url = "https://api.dropboxapi.com/oauth2/token"
                  data = {
                      "grant_type": "refresh_token",
                      "refresh_token": refresh_token,
                      "client_id": app_key,
                      "client_secret": app_secret
                  }
                  
                  response = requests.post(token_url, data=data)
                  response_json = response.json()
                  
                  if response.status_code == 200:
                      print("Successfully refreshed access token")
                      return response_json["access_token"]
                  else:
                      print(f"Token refresh failed with status code: {response.status_code}")
                      print(f"Error response: {response_json}")
                      raise Exception(f"Failed to refresh access token: {response_json.get('error_description', 'Unknown error')}")
              except Exception as e:
                  print(f"Error during token refresh: {str(e)}")
                  raise
          
          def get_dropbox_client():
              """Initialize Dropbox client with manual token refresh"""
              try:
                  print("Initializing Dropbox client...")
                  access_token = refresh_access_token()
                  return dropbox.Dropbox(access_token)
              except Exception as e:
                  print(f"Failed to initialize Dropbox client: {str(e)}")
                  raise

          # Initialize temp directory path at the global scope
          temp_dir = Path("temp")
          
          def clean_directory(directory):
              """Recursively remove a directory and its contents"""
              try:
                  if isinstance(directory, str):
                      directory = Path(directory)
                  if directory.exists():
                      shutil.rmtree(directory)
              except Exception as e:
                  print(f"Error cleaning directory {directory}: {str(e)}")

          # Rest of the functions remain the same...
          [Previous functions here]

          try:
              print("Starting backup process...")
              print(f"Using endpoint: {os.environ["S3_ENDPOINT"]}")
              print(f"Using bucket: {os.environ["S3_BUCKET_NAME"]}")
              
              # Initialize S3 client with Supabase config
              session = boto3.Session(
                  aws_access_key_id=os.environ["S3_ACCESS_KEY_ID"],
                  aws_secret_access_key=os.environ["S3_SECRET_ACCESS_KEY"],
                  region_name=os.environ["S3_REGION"]
              )
              
              s3 = session.client("s3",
                  endpoint_url=os.environ["S3_ENDPOINT"],
                  config=boto3.session.Config(signature_version="s3v4")
              )
              
              # Clean up any existing temp directory
              clean_directory(temp_dir)
              temp_dir.mkdir(exist_ok=True)
              
              try:
                  # Initialize Dropbox client
                  dbx = get_dropbox_client()
                  
                  # Rest of the backup process...
                  [Previous backup process code here]
                  
              except Exception as e:
                  print(f"Error during backup process: {str(e)}")
                  send_heartbeat("fail", f"Backup failed: {str(e)}")
                  raise
              finally:
                  # Always clean up temp directory
                  clean_directory(temp_dir)
          
          except Exception as e:
              error_message = f"Backup failed: {str(e)}"
              send_heartbeat("fail", error_message)
              print(error_message)
              raise
          '

      - name: Send Final Heartbeat on Failure
        if: failure()
        run: |
          curl -X GET ${{ env.BETTER_STACK_HEARTBEAT }}/fail

      - name: Send Final Heartbeat on Success
        if: success()
        run: |
          curl -X GET ${{ env.BETTER_STACK_HEARTBEAT }}
